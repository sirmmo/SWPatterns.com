[{"pk": 1, "model": "pattern.pattern", "fields": {"motivation": "When dealing with tree-structured data, programmers often have to discriminate between a leaf-node and a branch. This makes code more complex, and therefore, error prone. The solution is an interface that allows treating complex and primitive objects uniformly. In object-oriented programming, a composite is an object designed as a composition of one-or-more similar objects, all exhibiting similar functionality. This is known as a \"has-a\" relationship between objects.[2] The key concept is that you can manipulate a single instance of the object just as you would manipulate a group of them. The operations you can perform on all the composite objects often have a least common denominator relationship. For example, if defining a system to portray grouped shapes on a screen, it would be useful to define resizing a group of shapes to have the same effect (in some sense) as resizing a single shape.", "name": "Composite", "consequences": " Implementing the composite pattern lets clients treat individual objects and compositions uniformly.[1]", "tags": [1], "intent": "Composite can be used when clients should ignore the difference between compositions of objects and individual objects.[1] If programmers find that they are using multiple objects in the same way, and often have nearly identical code to handle each of them, then composite is a good choice; it is less complex in this situation to treat primitives and composites as homogeneous.", "structure": "[Component| +operation()]^-[Composite| +operation(); +add(); +remove(); +getChild(){bg:orange}], [Component]^-[Leaf| +operation()], [Composite]+->[Component]", "description": "The composite pattern describes that a group of objects are to be treated in the same way as a single instance of an object. The intent of a composite is to \"compose\" objects into tree structures to represent part-whole hierarchies."}}, {"pk": 2, "model": "pattern.pattern", "fields": {"motivation": "The factory determines the actual concrete type of object to be created, and it is here that the object is actually created (in C++, for instance, by the new operator). However, the factory only returns an abstract pointer to the created concrete object.\r\nThis insulates client code from object creation by having clients ask a factory object to create an object of the desired abstract type and to return an abstract pointer to the object.[2]\r\nAs the factory only returns an abstract pointer, the client code (that requested the object from the factory) does not know \u2013 and is not burdened by \u2013 the actual concrete type of the object that was just created. However, the type of a concrete object (and hence a concrete factory) is known by the abstract factory; for instance, the factory may read it from a configuration file. The client has no need to specify the type, since it has already been specified in the configuration file.", "name": "Abstract factory", "consequences": "Use of this pattern makes it possible to interchange concrete implementations without changing the code that uses them, even at runtime. However, employment of this pattern, as with similar design patterns, may result in unnecessary complexity and extra work in the initial writing of code. Used correctly the \"extra work\" pays off in the second implementation of the factory.", "tags": [1], "intent": "The essence of the Abstract Factory method Pattern is to \"Provide an interface for creating families of related or dependent objects without specifying their concrete classes\".", "structure": "[ElementFactory| +createElement(){bg:orange}]", "description": "The abstract factory pattern is a software design pattern that provides a way to encapsulate a group of individual factories that have a common theme. In normal usage, the client software creates a concrete implementation of the abstract factory and then uses the generic interfaces to create the concrete objects that are part of the theme. The client does not know (or care) which concrete objects it gets from each of these internal factories, since it uses only the generic interfaces of their products. This pattern separates the details of implementation of a set of objects from their general usage.\r\nAn example of this would be an abstract factory class DocumentCreator that provides interfaces to create a number of products (e.g. createLetter() and createResume()). The system would have any number of derived concrete versions of the DocumentCreator class like FancyDocumentCreator or ModernDocumentCreator, each with a different implementation of createLetter() and createResume() that would create a corresponding object like FancyLetter or ModernResume. Each of these products is derived from a simple abstract class like Letter or Resume of which the client is aware. The client code would get an appropriate instance of the DocumentCreator and call its factory methods. Each of the resulting objects would be created from the same DocumentCreator implementation and would share a common theme (they would all be fancy or modern objects). The client would need to know how to handle only the abstract Letter or Resume class, not the specific version that it got from the concrete factory.\r\nA factory is the location or a concrete class in the code at which objects are constructed. The intent in employing the pattern is to insulate the creation of objects from their usage. This allows for new derived types to be introduced with no change to the code that uses the base class."}}, {"pk": 3, "model": "pattern.pattern", "fields": {"motivation": "The creation of an object often requires complex processes not appropriate to include within a composing object. The object's creation may lead to a significant duplication of code, may require information not accessible to the composing object, may not provide a sufficient level of abstraction, or may otherwise not be part of the composing object's concerns. The factory method design pattern handles these problems by defining a separate method for creating the objects, which subclasses can then override to specify the derived type of product that will be created.", "name": "Factory Method", "consequences": "A factory method has a distinct name. In many object-oriented languages, constructors must have the same name as the class they are in, which can lead to ambiguity if there is more than one way to create an object (see overloading). Factory methods have no such constraint and can have descriptive names. As an example, when complex numbers are created from two real numbers the real numbers can be interpreted as Cartesian or polar coordinates, but using factory methods, the meaning is clear.", "tags": [1], "intent": "The factory pattern can be used when:\r\n- The creation of an object precludes its reuse without significant duplication of code.\r\n- The creation of an object requires access to information or resources that should not be contained within the composing class.\r\n- The lifetime management of the generated objects must be centralized to ensure a consistent behavior within the application.\r\nFactory methods are common in toolkits and frameworks, where library code needs to create objects of types that may be subclassed by applications using the framework.\r\nParallel class hierarchies often require objects from one hierarchy to be able to create appropriate objects from another.", "structure": "[Creator|+createProduct():Product{bg:white}]^-[ConcreteCreator|+createProduct():Product{bg:orange}],\r\n[ConcreteCreator]-.->[Product]", "description": "The factory method pattern is an object-oriented design pattern to implement the concept of factories. Like other creational patterns, it deals with the problem of creating objects (products) without specifying the exact class of object that will be created. The essence of the Factory method Pattern is to \"Define an interface for creating an object, but let the classes that implement the interface decide which class to instantiate. The Factory method lets a class defer instantiation to subclasses.\"[1]\r\n"}}, {"pk": 4, "model": "pattern.pattern", "fields": {"motivation": "Tracking operations and things the user does is important to understand the features and the latent design of products. ", "name": "Session", "consequences": "Good news: you can control and track everything the user does in the flow. Bad news: You don't know when the user leaves the desktop or the phone. ", "tags": [3, 4], "intent": "The intent of the Session Pattern is to bind something client-side to something server-side regulating a specific flow of operations. Anthing can be used as session token, but typically uuids ore guids are the best choice.", "structure": "[Server]-.-gives token>[Client],\r\n[Client]-.-attaches token>[Server]", "description": "The session pattern has a long history coming from the time when webapps didn't have real computational power, and arrives directly to Android when you need some operations to behave in a certain manner i.e. A specific flow you want to track."}}, {"pk": 5, "model": "pattern.pattern", "fields": {"motivation": "The Fluent Pattern is dictaded by elegance and readability.", "name": "Fluent", "consequences": "The code is more readable, and it helps one-liner aficionados keep loving the library. If uesd in a wrong manner it can easily explode destroying usability.", "tags": [5], "intent": "The Fluent Pattern's only intent is to enhance readability of the code and avoid if possible the enormous sequences of operations on the same object.", "structure": "[Object|+state_changing_method():Object]", "description": "Fluent is a coding pattern, meaning it is a way to implement methods. Ususally state-changing methods return void, while with fluent typically they would change the state of the object and return the object itself, enabling elegant sequences of operations."}}, {"pk": 1, "model": "pattern.tags", "fields": {"name": "GOF", "icon": "https://encrypted-tbn3.google.com/images?q=tbn:ANd9GcTxqhw3FE6rbX8kcnjssCQafemH94RotY8D1kkJas8Yzc8XdGBR"}}, {"pk": 2, "model": "pattern.tags", "fields": {"name": "Ajax", "icon": "http://iosysdevelopment.com/images/icon_ajax.jpg"}}, {"pk": 3, "model": "pattern.tags", "fields": {"name": "Android", "icon": "http://2.bp.blogspot.com/-_6agVqVYcDk/Try-zzbd-GI/AAAAAAAAAWE/TIgX6oe8lyw/s1600/android_42.png"}}, {"pk": 4, "model": "pattern.tags", "fields": {"name": "Web", "icon": "http://memberhub.com/images/website/web_icon_large-fp-6a3b023723b4c22eb1f8e1b5a9646b7c.png"}}, {"pk": 5, "model": "pattern.tags", "fields": {"name": "Coding", "icon": "https://encrypted-tbn1.google.com/images?q=tbn:ANd9GcSxFhYCQ7X_7i6PwdqOV8tFmSkqZy4qfhUtOuv2EltyPVdUmM1i"}}, {"pk": 1, "model": "pattern.language", "fields": {"super_lang": null, "wikipedia": "http://en.wikipedia.org/wiki/Php", "name": "PHP"}}, {"pk": 2, "model": "pattern.language", "fields": {"super_lang": null, "wikipedia": "http://en.wikipedia.org/wiki/Erlang_(programming_language)", "name": "Erlang"}}, {"pk": 3, "model": "pattern.language", "fields": {"super_lang": null, "wikipedia": "http://en.wikipedia.org/wiki/Python_(programming_language)", "name": "Python"}}, {"pk": 4, "model": "pattern.language", "fields": {"super_lang": null, "wikipedia": "http://en.wikipedia.org/wiki/Javascript", "name": "JavaScript"}}, {"pk": 5, "model": "pattern.language", "fields": {"super_lang": 4, "wikipedia": "http://en.wikipedia.org/wiki/Jquery", "name": "jQuery"}}, {"pk": 6, "model": "pattern.language", "fields": {"super_lang": null, "wikipedia": "http://en.wikipedia.org/wiki/ActionScript", "name": "ActionScript"}}, {"pk": 7, "model": "pattern.language", "fields": {"super_lang": null, "wikipedia": "http://en.wikipedia.org/wiki/C_Sharp_(programming_language)", "name": "C#"}}, {"pk": 8, "model": "pattern.language", "fields": {"super_lang": null, "wikipedia": "http://en.wikipedia.org/wiki/Java_(programming_language)", "name": "Java"}}, {"pk": 9, "model": "pattern.language", "fields": {"super_lang": null, "wikipedia": "http://en.wikipedia.org/wiki/Ruby_(programming_language)", "name": "Ruby"}}, {"pk": 10, "model": "pattern.language", "fields": {"super_lang": null, "wikipedia": "http://en.wikipedia.org/wiki/C_(programming_language)", "name": "C"}}, {"pk": 11, "model": "pattern.language", "fields": {"super_lang": null, "wikipedia": "http://en.wikipedia.org/wiki/C%2B%2B", "name": "C++"}}, {"pk": 12, "model": "pattern.language", "fields": {"super_lang": null, "wikipedia": "http://en.wikipedia.org/wiki/Scala_(programming_language)", "name": "Scala"}}, {"pk": 1, "model": "pattern.implementation", "fields": {"pattern": 1, "file": null, "gist": 1523081, "language": 1}}, {"pk": 2, "model": "pattern.implementation", "fields": {"pattern": 2, "file": "AbstractFactory.java", "gist": 1180801, "language": 8}}, {"pk": 3, "model": "pattern.implementation", "fields": {"pattern": 3, "file": "FactoryMethod.java", "gist": 1180801, "language": 8}}, {"pk": 2, "model": "pattern.use", "fields": {"name": "jQuery core", "language": [4], "url": "https://github.com/jquery/jquery/blob/master/src/core.js", "pattern": 5, "line_start": 230, "line_end": 235}}, {"pk": 3, "model": "pattern.use", "fields": {"name": "Django QuerySet", "language": [3], "url": "https://github.com/django/django/blob/master/django/db/models/query.py", "pattern": 5, "line_start": 625, "line_end": 657}}]